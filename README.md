[comment]: <> (Header Generated by ActionStatus 2.0.6 - 494)

[![Test results][tests shield]][actions] [![Latest release][release shield]][releases] [![swift 6.0 shield]][swift] ![Platforms: macOS][platforms shield]

[release shield]: https://img.shields.io/github/v/release/elegantchaos/Versionator
[platforms shield]: https://img.shields.io/badge/platforms-macOS-lightgrey.svg?style=flat "macOS"
[tests shield]: https://github.com/elegantchaos/Versionator/workflows/Tests/badge.svg
[swift 6.0 shield]: https://img.shields.io/badge/swift-6.0-F05138.svg "Swift 6.0"

[swift]: https://swift.org
[releases]: https://github.com/elegantchaos/Versionator/releases
[actions]: https://github.com/elegantchaos/Versionator/actions

[comment]: <> (End of ActionStatus Header)

# Versionator

This plugin gathers version information and embeds it into the package/executable, in a way that allows it to be retrieved at runtime.

We actually generate a few files:

- a `Version.swift` file which then gets built into the package
- an `Info.plist` file which gets embedded as a package resource
- a `Info.plisth` a C-style header file, with a non-standard extension so that is bundled into the resources

See https://github.com/elegantchaos/VersionatorTest for an example command line tool which uses the plugin.

## Swift API

The generated Swift API defines a `CurrentVersion` struct, with some static properties:

```swift
public struct VersionatorVersion {
  static let string = "1.0.0"
  static let build = 4
  static let commit = "g70f8f9a"
  static let git = "v1.0.0-0-g70f8f9a"
  static let tag = "v1.0.0"
  static let full = "1.0.0 (4)"
}
```

The build number is derived from the git commit count on the current branch. This is a fairly standard technique.

The git-style string is derived from the latest version tag on the current branch. 

Currently I'm just returning it verbatim, but the plugin could be extended to parse this more fully.


## Info.plist

This plugin also generates an `Info.plist`, which gets bundled into the package resources.

This can then be accessed with `Bundle.module.infoDictionary`.

## Header Files

For Xcode-based applications, the `Info.plist` will probably need to include many other values, so using the file generated by Versionator won't be an option.

In this case, a better approach is to have a local package which uses the Versionator plugin, and to then set the `INFOPLIST_PREFIX_HEADER` to point at the generated `Info.plisth` file in the local package's resource bundle.

This file defines some variables: 

```c
#define BUILD 4
#define CURRENT_PROJECT_VERSION 4
#define COMMIT "70f8f9a"
#define GIT_VERSION "v1.0.0-0-g70f8f9a"
#define GIT_TAG "v1.0.0"
```

You can then substitute these into your `Info.plist` definitions, using the normal synax - e.g: `${GIT_VERSION}`.

_Note that we use a non-standard file extension here to avoid Swift Package Manager getting confused. Generating a `.h` file will cause SPM to treat the package as being mixed Swift/C, which is not allowed in this context._

For an alternative approach to generating an Info.plist, see also [Infomatic Plugin](https://github.com/elegantchaos/InfomaticPlugin).
 

## Xcode Issues?

**Note**: Outputting resources from a build tool like this seems to produce a cyclic-dependency warning in previous versions of Xcode, due to the fact that the client executable uses the bundle, and the bundle contains the Info.plist, but Xcode seems to think that the Info.plist depends on the executable target.

I'm not sure if this is a bug with the Xcode integration. Building with SPM from the command line doesn't produce the same errors - which might be because they aren't there, or might be a failure to report them.

I did wonder if this would be fixed by making the plugin _prebuild_ instead of _build_. That is what I initially tried to do, but unfortunately prebuild plugins seem to have a limitation in that the tool they run can only be a binaryTarget - ie a precompiled binary that's been commited/uploaded elsewhere. That's a bit of a rubbish limitation right now for such a simple plugin, and it really cramps one's style whilst developing the plugin, so I switched to using a build plugin instead. Hopefully this limitation will be fixed, and might in turn fix the Xcode problem.   
