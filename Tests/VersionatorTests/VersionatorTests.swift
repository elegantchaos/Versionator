import Foundation
import Runner
import Testing
import VersionatorUtils

@testable import Runner

/// Test with a task that has a zero status.
@Test func testTool() async throws {
  let test = Test.current!
  try await test.inTempFolder { folder in
    let fm = FileManager.default

    // copy example repo into temp folder
    let exampleRepo = Bundle.module.url(forResource: "Example", withExtension: "git")!
    let repoFolder = folder.appending(path: "Example.git")
    try fm.copyItem(at: exampleRepo, to: repoFolder)

    // rename .git folder inside repo
    try fm.moveItem(at: repoFolder.appending(path: "git"), to: repoFolder.appending(path: ".git"))

    // run the tool over the repo
    let url = test.urlForTool("VersionatorTool")
    let runner = Runner(for: url, cwd: repoFolder)
    let files = ["Version.swift", "Version.plist", "Version.h", "Info.plisth"]
    var args = ["--verbose", "./"]
    let paths = files.map { folder.appending(component: $0) }
    args.append(contentsOf: paths.map { $0.path })
    let output = await runner.run(args)
      .stdout.string

    // check files were generated
    #expect(output.contains("Generated Version.swift"))
    #expect(output.contains("Generated Version.h"))
    #expect(output.contains("Generated Version.plist"))
    #expect(output.contains("Generated Info.plisth"))

    // check content matches expected
    for url in paths {
      let content = try Data(contentsOf: url)
      let expectedURL = Bundle.module.url(forResource: "Example.out/\(url.deletingPathExtension().lastPathComponent)", withExtension: url.pathExtension)!
      let expected = try Data(contentsOf: expectedURL)
      #expect(content == expected, "content does not match expected for \(url.lastPathComponent)")
    }
  }
}

// , backupItemName: String?, options: FileManager.ItemReplacementOptions, resultingItemURL: AutoreleasingUnsafeMutablePointer<NSURL?>?)
// // let folder = URL(fileURLWithPath: "/Users/sam/Desktop/VersionatorTests")
// // make a sample repo
// let script = Runner(for: Bundle.module.url(forResource: "make-repo", withExtension: "sh")!)
// #expect(await script.run([folder.path]).waitUntilExit() == .succeeded)

// let templates = [
//   """
//   /// This file is generated by Versionator -- DO NOT EDIT.
//   /// See github.com/elegantchaos/Versionator for more info.
//   public struct VersionatorVersion {
//       static let string = "\(expectedCommit)"
//       static let build = \(expectedVer)
//       static let commit = ""
//       static let git = "\(expectedCommit)"
//       static let tag = "\(expectedCommit)"
//       static let full = "\(expectedCommit) (\(expectedVer))"
//   }
//   """,
//   """
//   /// This file is generated by Versionator -- DO NOT EDIT.
//   /// See github.com/elegantchaos/Versionator for more info.
//   #define BUILD \(expectedVer)
//   #define CURRENT_PROJECT_VERSION \(expectedVer)
//   #define COMMIT
//   #define GIT_VERSION "\(expectedCommit)"
//   #define GIT_TAG "\(expectedCommit)"
//   """,
//   """
//   /// This file is generated by Versionator -- DO NOT EDIT.
//   /// See github.com/elegantchaos/Versionator for more info.
//   public struct VersionatorVersion {
//       static let string = "\(expectedCommit)"
//       static let build = \(expectedVer)
//       static let commit = ""
//       static let git = "\(expectedCommit)"
//       static let tag = "\(expectedCommit)"
//       static let full = "\(expectedCommit) (\(expectedVer))"
//   }
//   """,
//   """
//   /// This file is generated by Versionator -- DO NOT EDIT.
//   /// See github.com/elegantchaos/Versionator for more info.
//   #define BUILD \(expectedVer)
//   #define CURRENT_PROJECT_VERSION \(expectedVer)
//   #define COMMIT
//   #define GIT_VERSION "\(expectedCommit)"
//   #define GIT_TAG "\(expectedCommit)"
//   """,
// ]

// var format = PropertyListSerialization.PropertyListFormat.xml
// let data = try PropertyListSerialization.propertyList(from: Data(contentsOf: url), options: [], format: &format)
// content = String(describing: data)
// content = String(describing: try PropertyListSerialization.propertyList(from: try Data(contentsOf: url), options: [], format: .binary))
